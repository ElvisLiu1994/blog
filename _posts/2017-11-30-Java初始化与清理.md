---
layout: post
title:  Java初始化与清理
date:   2017-11-30
category: Thinking in Java
tag: 构造过程 笔记
---

* content
{:toc}


### 用构造器确保初始化
1. 当使用`new`关键字创建一个对象时，编译器会先给该对象分配相应的内存空间，然后调用`new`关键字后面的构造方法完成对象的初始化工作，这两个过程是紧密联系在一起的。  
<br/>
2. 通过参数列表的不同（包括个数不同，类型不同，甚至顺序不同，不过不建议通过顺序不同来区分两个重载方法，这样会造成程序的混乱）可以重载多个构造器，不能以返回值的不同区分重载方法。一旦自己定义了一个构造器，无论是否有参，编译器都不会再创建默认构造器了。  
<br/>
3. 在构造器中可以通过`this`关键字调用其他的构造器，<strong>但是，只能用`this`调用一个构造器，也必须将构造器调用置于最起始处，否则编译器会报错</strong>。除构造器之外，编译器禁止在其他任何地方调用构造器。

### 终结处理和垃圾回收
1. 垃圾回收器只会释放那些经由`new`分配的内存，也就是堆中的内存，如果是通过`native`方法比如调用`C语言函数`中，使用`malloc函数`分配的内存空间，尽管使用完成后，这些内存空间也是不被垃圾回收器控制的，这时候需要使用`finalize`函数中调用本地方法`free()`来释放那部分特殊空间。  
<br/>
2. <strong>对象可能不被垃圾回收</strong>，只有在堆内存不够用的时候才有可能进行垃圾回收，所以finalize函数不一定会被调用。  
3. <strong>垃圾回收并不等于“析构”</strong>  
4. <strong>垃圾回收只与内存有关</strong>  
<br/>
5. 不要期望用`finalize`来进行一些清理工作，它的用法非常晦涩，不建议使用。  

### 成员的初始化
1. 类的成员变量不显示进行初始化会有`默认初始值`，但是局部变量(如函数内部声明的变量)不进行初始化会报错。  
<br/>
2. <strong>先对成员变量进行初始化之后，再执行构造器中的内容。</strong>  
<br/>
3. `static`关键字不能作用于局部变量，只能作用于域。  
<br/>
4. 初始化的顺序是`先静态对象`，而`后非静态对象`。当首次生成这个类的对象，或者首次访问静态数据时，执行静态代码块一次。  
<br/>
5. 静态代码块与非静态代码块，都会先于构造器执行。

### 局部变量初始化
1. 局部变量存在于`方法`和`代码块`中，且局部变量在栈中分配空间，而且局部变量一定要进行初始化，因为不会有默认值。  
<br/>
2. 但是如果局部变量是一个`引用`，对其如果使用`new`关键字进行初始化的话，该`引用`在存储在栈中，但是`new`出来的空间是在堆中的，该引用指向的堆内存空间会被清零，即得到与成员变量一样的默认值。  
<br/>
3. 比如，在下列方法中，对`dp`数组中的元素不需要进行清零，因为其使用了`new`进行初始化，那么堆空间中，数组的所有元素都会被清零。
```java
    public static int numDistinct(String s, String t) {
        int m = s.length();
        int n = t.length();
        
        // 边界情况
        if(m < n || m == 0) return 0;
        if(m == n && s.equals(t)) return 1;
        
        //虽然dp是一个局部变量，但是由于使用了new关键字，所以是在堆上分配了内存空间，然后进行了初始化为默认值。
        int[][] dp = new int[m+1][n+1]; 
        for(int i = 0; i <= m; i++)
            dp[i][0] = 1; // 所有的串都包含1个空串
        
        for(int i = 1; i <= m; i++) {
            for(int j = 1; j <= n; j++) { // 这里也可以用(j<=i && j<=n)结果是一样的
                if(s.charAt(i-1) != t.charAt(j-1)) {
                    dp[i][j] = dp[i-1][j];
                }else {
                    dp[i][j] = dp[i-1][j] + dp[i-1][j-1];
                }
            }
        }
        
        return dp[m][n];
    }
```

### 举例对象的创建过程(假设有个名为Dog的类)
1. <strong>即使没有显式地使用`static`关键字，构造器实际上也是静态方法。</strong>因此，当首次创建`Dog对象`时，或者Dog类的静态方法/静态域首次被访问时，Java解释器必须查找类路径，以定位`Dog.class`文件。  
<br/>
2. 然后载入`Dog.class`文件，有关`静态初始化`的动作都会执行。因此，静态初始化只在Class对象首次加载的时候进行一次。  
<br/>
3. 当用`new Dog()`创建对象的时候，首先将在堆上为`Dog对象`分配足够的存储空间。  
<br/>
4. 这块空间将被`清零`，这就自动地将`Dog对象`中的所有`基本类型`数据都设置成了`默认值`，而`引用`则被设置成为`null`。  
<br/>
5. 执行所有出现于字段定义处的初始化动作。（包括字段的初始化，以及`非静态代码块`的初始化【非静态代码块对于支持匿名内部类的初始化是必须的】）  
<br/>
6. `执行构造器`。这可能会牵涉到很多动作，尤其是涉及继承的时候。


### 初始化基类
1. 当创建一个导出类的对象时，该对象包含了一个基类的子对象。这个子对象与用基类直接创建的对象是一样的。二者的区别在于，后者来自于外部，而基类的子对象被包装在导出类对象的内部。  
<br/>
2. 由于会自动创建一个基类的对象，Java会自动在导出类的构造器中插入对基类构造器的调用。即使不为导出类创建构造器，编译器也会通过插入默认的构造器，该构造器将会调用基类的默认构造器。  
<br/>
3. 如果基类没有无参构造器，比如仅显示定义了一个有参构造器，那么编译器将不会自动生成无参构造器了。这样就必须用关键字<strong>`super`</strong>显示地编写调用基类构造器的语句，并且必须放在第一行。如果不在导出类的构造器中调用基类构造器，编译器将产生`无法找到符合BaseClassName()形式的构造器`的错误。
