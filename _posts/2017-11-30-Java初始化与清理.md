---
layout: post
title:  Java初始化与清理
date:   2017-11-30
category: Thinking in Java
tag: java 构造过程 笔记
---

* content
{:toc}


### 用构造器确保初始化
1. 当使用new关键字创建一个对象时，编译器会先给该对象分配相应的内存空间，然后调用new关键字后面的构造方法完成对象的初始化工作，这两个过程是紧密联系在一起的。  
2. 通过参数列表的不同（包括个数不同，类型不同，甚至顺序不同，不过不建议通过顺序不同来区分两个重载方法，这样会造成程序的混乱）可以重载多个构造器，不能以返回值的不同区分重载方法。一旦自己定义了一个构造器，无论是否有参，编译器都不会再创建默认构造器了。  
3. 在构造器中可以通过this关键字调用其他的构造器，<strong>但是，只能用this调用一个构造器，也必须将构造器调用置于最起始处，否则编译器会报错</strong>。除构造器之外，编译器禁止在其他任何地方调用构造器。

### 终结处理和垃圾回收
1. 垃圾回收器只会释放那些经由new分配的内存，也就是堆中的内存，如果是通过native方法比如调用C语言函数中，使用malloc函数分配的内存空间，尽管使用完成后，这些内存空间也是不被垃圾回收器控制的，这时候需要使用finalize函数中调用本地方法free()来释放那部分特殊空间。
2. <strong>对象可能不被垃圾回收</strong>，只有在堆内存不够用的时候才有可能进行垃圾回收，所以finalize函数不一定会被调用。
3. <strong>垃圾回收并不等于“析构”</strong>
4. <strong>垃圾回收只与内存有关</strong>
5. 不要期望用finalize来进行一些清理工作，它的用法非常晦涩，不建议使用。

### 成员的初始化
1. 类的成员变量不显示进行初始化会有默认初始值，但是局部变量(如函数内部声明的变量)不进行初始化会报错。
2. 先对成员变量进行初始化之后，再执行构造器中的内容。
3. static关键字不能作用于局部变量，只能作用于域。
4. 初始化的顺序是先静态对象，而后是非静态对象。当首次生成这个类的对象，或者首次访问静态数据时，执行静态代码块一次。
5. 静态代码块与非静态代码块，都会先于构造器执行。

##### 初始化基类
1. 当创建一个导出类的对象时，该对象包含了一个基类的子对象。这个子对象与用基类直接创建的对象是一样的。二者的区别在于，后者来自于外部，而基类的子对象被包装在导出类对象的内部。
2. 由于会自动创建一个基类的对象，Java会自动在导出类的构造器中插入对基类构造器的调用。即使不为导出类创建构造器，编译器也会通过插入默认的构造器，该构造器将会调用基类的默认构造器。
3. 如果基类没有无参构造器，比如仅显示定义了一个有参构造器，那么编译器将不会自动生成无参构造器了。这样就必须用关键字<strong>super</strong>显示地编写调用基类构造器的语句，并且必须放在第一行。如果不在导出类的构造器中调用基类构造器，编译器将产生`无法找到符合BaseClassName()形式的构造器`的错误。

