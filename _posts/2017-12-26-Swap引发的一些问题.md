---
layout: post
title: Java实现Swap引发的一些思考   
date: 2017-12-20
category: Java
tag: swap
---

* content
{:toc}


# Java实现Swap函数引发的一些思考

假设我们有如下需求：
```java
public static void swap(Integer i1, Integer i2) {

}

public static void main(String[] args) {
    Integer a = 1;
    Integer b = 2;
    System.out.println("a = " + a + ", b = " + b);
    swap(a, b);
    System.out.println("a = " + a + ", b = " + b);
}
```
即如何实现两个整型包装类型数据的交换。我们都知道，如果传入的是基本类型`int`的话，那么肯定是无法完成的，因为在`Java`中对于基本类型是使用的值传递方式。所以这里只关注参数为引用类型时的情况。

这个问题看似简单，首先想到的方法：
```java
public static void swap(Integer i1, Integer i2) {
    Integer tmp = i1;
    i2 = i1;
    i1 = tmp;
}
```
看看它的输出为：
```
a = 1, b = 2
a = 1, b = 2
```

这是什么原因呢？`Java`对于引用类型的数据，在传参时使用的是引用传递，即将实参的引用传给形参，在函数内部，`i1`指向的对象与`a`指向同一块内存空间，`i2`与`b`指向同一块内存空间，它们的值是一样的(引用值)。如下图所示：
<center>
<img src="{{ '/styles/images/swap1.png' | prepend: site.baseurl }}" width="50%" height="50%" />
</center>

在`swap`函数里面，i1与i2确实发生了交换，但是它们对a和b的指向没有任何影响：
<center>
<img src="{{ '/styles/images/swap2.png' | prepend: site.baseurl }}" width="50%" height="50%" />
</center>

个人理解，Java里面的参数传递类似于浅拷贝，即将实参引用的值拷贝给了形参，即形参与实参指向了同一块内存空间，对于所有的引用类型来讲，都不能通过这种方式达到交换的目的，因为传完参之后，实参的引用值并不会发生变化，所以在函数内部，如果仅仅只是对引用值进行操作，始终影响不了实参的指向。而如果要达到交换的目的，只有通过直接操作内存中存储的值进行交换，即把i1指向的内存空间的内容替换成i2指向的内容，这样更改才能达到交换的效果。
